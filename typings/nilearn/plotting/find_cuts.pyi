"""
This type stub file was generated by pyright.
"""

"""Tools to find activations and cut on maps."""
DEFAULT_CUT_COORDS = ...
def find_xyz_cut_coords(img, mask_img=..., activation_threshold=...): # -> Any:
    """Find the center of the largest activation connected component.

    Parameters
    ----------
    img : 3D Nifti1Image
        The brain map.

    mask_img : 3D Nifti1Image, optional
        An optional brain mask, provided mask_img should not be empty.

    activation_threshold : float, optional
        The lower threshold to the positive activation. If None, the
        activation threshold is computed using the 80% percentile of
        the absolute value of the map.

    Returns
    -------
    x : float
        The x world coordinate.

    y : float
        The y world coordinate.

    z : float
        The z world coordinate.

    """
    ...

def find_cut_slices(img, direction=..., n_cuts=..., spacing=...): # -> NDArray[Any]:
    """Find 'good' cross-section slicing positions along a given axis.

    Parameters
    ----------
    img : 3D Niimg-like object
        See :ref:`extracting_data`.
        The brain map.

    direction : string, optional
        Sectional direction; possible values are "x", "y", or "z".
        Default='z'.

    n_cuts : int, optional
        Number of cuts in the plot. Default=7.

    spacing : 'auto' or int, optional
        Minimum spacing between cuts (in voxels, not millimeters)
        if 'auto', the spacing is .5 / n_cuts * img_length.
        Default='auto'.

    Returns
    -------
    cut_coords : 1D array of length n_cuts
        The computed cut_coords.

    Notes
    -----
    This code works by iteratively locating peak activations that are
    separated by a distance of at least 'spacing'. If n_cuts is very
    large and all the activated regions are covered, cuts with a spacing
    less than 'spacing' will be returned.

    Warnings
    --------
    If a non-diagonal img is given. This function automatically reorders
    img to get it back to diagonal. This is to avoid finding same cuts in
    the slices.

    """
    ...

def find_parcellation_cut_coords(labels_img, background_label=..., return_label_names=..., label_hemisphere=...): # -> tuple[NDArray[Any], list[Unknown]] | NDArray[Any]:
    """Return coordinates of center of mass of 3D parcellation atlas.

    Parameters
    ----------
    labels_img : 3D Nifti1Image
        A brain parcellation atlas with specific mask labels for each
        parcellated region.

    background_label : int, optional
        Label value used in labels_img to represent background.
        Default=0.

    return_label_names : bool, optional
        Returns list of labels. Default=False.

    label_hemisphere : 'left' or 'right', optional
        Choice of hemisphere to compute label center coords for.
        Applies only in cases where atlas labels are lateralized.
        Eg. Yeo or Harvard Oxford atlas. Default='left'.

    Returns
    -------
    coords : numpy.ndarray of shape (n_labels, 3)
        Label regions cut coordinates in image space (mm).

    labels_list : list, optional
        Label region. Returned only when return_label_names is True.

    See Also
    --------
    nilearn.plotting.find_probabilistic_atlas_cut_coords : For coordinates
        extraction on probabilistic atlases (4D) (Eg. MSDL atlas)

    """
    ...

def find_probabilistic_atlas_cut_coords(maps_img): # -> NDArray[Any]:
    """Return coordinates of center probabilistic atlas 4D image.

    Parameters
    ----------
    maps_img : 4D Nifti1Image
        A probabilistic brain atlas with probabilistic masks in the fourth
        dimension.

    Returns
    -------
    coords : numpy.ndarray of shape (n_maps, 3)
        Label regions cut coordinates in image space (mm).

    See Also
    --------
    nilearn.plotting.find_parcellation_cut_coords : For coordinates
        extraction on parcellations denoted with labels (3D)
        (Eg. Harvard Oxford atlas)

    """
    ...

