"""
This type stub file was generated by pyright.
"""

from sklearn.base import BaseEstimator, TransformerMixin
from nilearn._utils.docs import fill_doc

"""Connectivity matrices."""
def sym_matrix_to_vec(symmetric, discard_diagonal=...):
    """Return the flattened lower triangular part of an array.

    If diagonal is kept, diagonal elements are divided by sqrt(2) to conserve
    the norm.

    Acts on the last two dimensions of the array if not 2-dimensional.

    .. versionadded:: 0.3

    Parameters
    ----------
    symmetric : numpy.ndarray or list of numpy arrays, shape\
        (..., n_features, n_features)
        Input array.

    discard_diagonal : boolean, optional
        If True, the values of the diagonal are not returned.
        Default=False.

    Returns
    -------
    output : numpy.ndarray
        The output flattened lower triangular part of symmetric. Shape is
        (..., n_features * (n_features + 1) / 2) if discard_diagonal is False
        and (..., (n_features - 1) * n_features / 2) otherwise.

    """
    ...

def vec_to_sym_matrix(vec, diagonal=...): # -> NDArray[float64]:
    """Return the symmetric matrix given its flattened lower triangular part.

    Acts on the last dimension of the array if not 1-dimensional.
    Diagonal can be encompassed in vec or given separately. In both cases, note
    that diagonal elements are multiplied by sqrt(2).

    .. versionadded:: 0.3

    Parameters
    ----------
    vec : numpy.ndarray or list of numpy arrays, shape \
        (..., n_columns * (n_columns + 1) /2) or
        (..., (n_columns - 1) * n_columns / 2) if diagonal is given separately.
        The input array.

    diagonal : numpy.ndarray, shape (..., n_columns), optional
        The diagonal array to be stacked to vec. If None, the diagonal is
        assumed to be included in vec.

    Returns
    -------
    sym : numpy.ndarray, shape (..., n_columns, n_columns).
        The output symmetric matrix.

    Notes
    -----
    This function is meant to be the inverse of sym_matrix_to_vec. If you have
    discarded the diagonal in sym_matrix_to_vec, you need to provide it
    separately to reconstruct the symmetric matrix. For instance this can be
    useful for correlation matrices for which we know the diagonal is 1.

    See Also
    --------
    nilearn.connectome.sym_matrix_to_vec

    """
    ...

def cov_to_corr(covariance):
    """Return correlation matrix for a given covariance matrix.

    Parameters
    ----------
    covariance : 2D numpy.ndarray
        The input covariance matrix.

    Returns
    -------
    correlation : 2D numpy.ndarray
        The output correlation matrix.

    """
    ...

def prec_to_partial(precision):
    """Return partial correlation matrix for a given precision matrix.

    Parameters
    ----------
    precision : 2D numpy.ndarray
        The input precision matrix.

    Returns
    -------
    partial_correlation : 2D numpy.ndarray
        The 2D output partial correlation matrix.

    """
    ...

@fill_doc
class ConnectivityMeasure(BaseEstimator, TransformerMixin):
    """A class that computes different kinds of functional connectivity \
    matrices.

    .. versionadded:: 0.2

    Parameters
    ----------
    cov_estimator : estimator object, optional.
        The covariance estimator. By default the LedoitWolf estimator
        is used. This implies that correlations are slightly shrunk
        towards zero compared to a maximum-likelihood estimate

    kind : {"covariance", "correlation", "partial correlation",\
            "tangent", "precision"}, optional
        The matrix kind.
        For the use of "tangent" see :footcite:`Varoquaux2010b`.
        Default='covariance'.

    vectorize : bool, optional
        If True, connectivity matrices are reshaped into 1D arrays and only
        their flattened lower triangular parts are returned. Default=False.

    discard_diagonal : bool, optional
        If True, vectorized connectivity coefficients do not include the
        matrices diagonal elements. Used only when vectorize is set to True.
        Default=False.

    %(standardize)s

        .. note::

            Added to control passing value to `standardize` of ``signal.clean``
            to call new behavior since passing "zscore" or True (default) is
            deprecated. This parameter will be deprecated in version 0.13 and
            removed in version 0.15.

    Attributes
    ----------
    `cov_estimator_` : estimator object
        A new covariance estimator with the same parameters as cov_estimator.

    `mean_` : numpy.ndarray
        The mean connectivity matrix across subjects. For 'tangent' kind,
        it is the geometric mean of covariances (a group covariance
        matrix that captures information from both correlation and partial
        correlation matrices). For other values for "kind", it is the
        mean of the corresponding matrices

    `whitening_` : numpy.ndarray
        The inverted square-rooted geometric mean of the covariance matrices.

    References
    ----------
    .. footbibliography::

    """
    def __init__(self, cov_estimator=..., kind=..., vectorize=..., discard_diagonal=..., standardize=...) -> None:
        ...
    
    def fit(self, X, y=...): # -> Self@ConnectivityMeasure:
        """Fit the covariance estimator to the given time series for each \
        subject.

        Parameters
        ----------
        X : list of numpy.ndarray, shape for each (n_samples, n_features)
            The input subjects time series. The number of samples may differ
            from one subject to another.

        Returns
        -------
        self : ConnectivityMatrix instance
            The object itself. Useful for chaining operations.

        """
        ...
    
    def fit_transform(self, X, y=..., confounds=...): # -> NDArray[Unknown] | ndarray[Unknown, Unknown] | NDArray[float32 | float64] | Any | ndarray[Any, dtype[Unknown | Any]] | NDArray[floating[Any]] | list[Unknown | Any] | list[Unknown]:
        """Fit the covariance estimator to the given time series \
        for each subject. \
        Then apply transform to covariance matrices for the chosen kind.

        Parameters
        ----------
        X : list of n_subjects numpy.ndarray with shapes \
            (n_samples, n_features)
            The input subjects time series. The number of samples may differ
            from one subject to another.

        confounds : np.ndarray with shape (n_samples) or \
                    (n_samples, n_confounds), or pandas DataFrame, optional
            Confounds to be cleaned on the vectorized matrices. Only takes
            into effect when vetorize=True.
            This parameter is passed to signal.clean. Please see the related
            documentation for details.

        Returns
        -------
        output : numpy.ndarray, shape (n_subjects, n_features, n_features) or \
            (n_subjects, n_features * (n_features + 1) / 2) if vectorize \
            is set to True.
            The transformed individual connectivities, as matrices or vectors.
            Vectors are cleaned when vectorize=True and confounds are provided.

        """
        ...
    
    def transform(self, X, confounds=...): # -> NDArray[Unknown] | ndarray[Unknown, Unknown] | NDArray[float32 | float64] | Any | ndarray[Any, dtype[Unknown | Any]] | NDArray[floating[Any]] | list[Unknown | Any] | list[Unknown]:
        """Apply transform to covariances matrices to get the connectivity \
        matrices for the chosen kind.

        Parameters
        ----------
        X : list of n_subjects numpy.ndarray with shapes \
            (n_samples, n_features)
            The input subjects time series. The number of samples may differ
            from one subject to another.

        confounds : numpy.ndarray with shape (n_samples) or \
                    (n_samples, n_confounds), optional
            Confounds to be cleaned on the vectorized matrices. Only takes
            into effect when vetorize=True.
            This parameter is passed to signal.clean. Please see the related
            documentation for details.

        Returns
        -------
        output : numpy.ndarray, shape (n_subjects, n_features, n_features) or \
            (n_subjects, n_features * (n_features + 1) / 2) if vectorize \
            is set to True.
            The transformed individual connectivities, as matrices or vectors.
            Vectors are cleaned when vectorize=True and confounds are provided.

        """
        ...
    
    def inverse_transform(self, connectivities, diagonal=...): # -> NDArray[Any] | NDArray[float64] | NDArray[Unknown]:
        """Return connectivity matrices from connectivities, \
        vectorized or not.

        If kind is 'tangent', the covariance matrices are reconstructed.

        Parameters
        ----------
        connectivities : list of n_subjects numpy.ndarray with shapes\
            (n_features, n_features) or (n_features * (n_features + 1) / 2,)
            or ((n_features - 1) * n_features / 2,)
            Connectivities of each subject, vectorized or not.

        diagonal : numpy.ndarray, shape (n_subjects, n_features), optional
            The diagonals of the connectivity matrices.

        Returns
        -------
        output : numpy.ndarray, shape (n_subjects, n_features, n_features)
            The corresponding connectivity matrices. If kind is 'correlation'/
            'partial correlation', the correlation/partial correlation
            matrices are returned.
            If kind is 'tangent', the covariance matrices are reconstructed.

        """
        ...
    


