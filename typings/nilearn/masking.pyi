"""
This type stub file was generated by pyright.
"""

from . import _utils
from ._utils import fill_doc

"""Utilities to compute and operate on brain masks."""
class MaskWarning(UserWarning):
    """A class to always raise warnings."""
    ...


@_utils.fill_doc
def intersect_masks(mask_imgs, threshold=..., connected=...): # -> Nifti1Image | FileBasedImage:
    """Compute intersection of several masks.

    Given a list of input mask images, generate the output image which
    is the threshold-level intersection of the inputs.

    Parameters
    ----------
    mask_imgs : :obj:`list` of Niimg-like objects
        See :ref:`extracting_data`.
        3D individual masks with same shape and affine.

    threshold : :obj:`float`, optional
        Gives the level of the intersection, must be within [0, 1].
        threshold=1 corresponds to keeping the intersection of all
        masks, whereas threshold=0 is the union of all masks.
        Default=0.5.
    %(connected)s
        Default=True.

    Returns
    -------
    grp_mask : 3D :class:`nibabel.nifti1.Nifti1Image`
        Intersection of all masks.
    """
    ...

@_utils.fill_doc
def compute_epi_mask(epi_img, lower_cutoff=..., upper_cutoff=..., connected=..., opening=..., exclude_zeros=..., ensure_finite=..., target_affine=..., target_shape=..., memory=..., verbose=...): # -> Nifti1Image | FileBasedImage:
    """Compute a brain mask from :term:`fMRI` data in 3D or \
    4D :class:`numpy.ndarray`.

    This is based on an heuristic proposed by T.Nichols:
    find the least dense point of the histogram, between fractions
    ``lower_cutoff`` and ``upper_cutoff`` of the total image histogram.

    .. note::

        In case of failure, it is usually advisable to
        increase ``lower_cutoff``.

    Parameters
    ----------
    epi_img : Niimg-like object
        See :ref:`extracting_data`.
        :term:`EPI` image, used to compute the mask.
        3D and 4D images are accepted.

        .. note::
            If a 3D image is given, we suggest to use the mean image.

    %(lower_cutoff)s
        Default=0.2.
    %(upper_cutoff)s
        Default=0.85.
    %(connected)s
        Default=True.
    %(opening)s
        Default=2.
    ensure_finite : :obj:`bool`
        If ensure_finite is True, the non-finite values (NaNs and infs)
        found in the images will be replaced by zeros
        Default=True.

    exclude_zeros : :obj:`bool`, optional
        Consider zeros as missing values for the computation of the
        threshold. This option is useful if the images have been
        resliced with a large padding of zeros.
        Default=False.
    %(target_affine)s

        .. note::
            This parameter is passed to :func:`nilearn.image.resample_img`.

    %(target_shape)s

        .. note::
            This parameter is passed to :func:`nilearn.image.resample_img`.

    %(memory)s
    %(verbose0)s

    Returns
    -------
    mask : :class:`nibabel.nifti1.Nifti1Image`
        The brain mask (3D image).
    """
    ...

@_utils.fill_doc
def compute_multi_epi_mask(epi_imgs, lower_cutoff=..., upper_cutoff=..., connected=..., opening=..., threshold=..., target_affine=..., target_shape=..., exclude_zeros=..., n_jobs=..., memory=..., verbose=...): # -> Nifti1Image | FileBasedImage:
    """Compute a common mask for several sessions or \
    subjects of :term:`fMRI` data.

    Uses the mask-finding algorithms to extract masks for each session
    or subject, and then keep only the main connected component of the
    a given fraction of the intersection of all the masks.

    Parameters
    ----------
    epi_imgs : :obj:`list` of Niimg-like objects
        See :ref:`extracting_data`.
        A list of arrays, each item being a subject or a session.
        3D and 4D images are accepted.

        .. note::

            If 3D images are given, we suggest to use the mean image
            of each session.

    threshold : :obj:`float`, optional
        The inter-session threshold: the fraction of the
        total number of sessions in for which a :term:`voxel` must be
        in the mask to be kept in the common mask.
        threshold=1 corresponds to keeping the intersection of all
        masks, whereas threshold=0 is the union of all masks.
    %(lower_cutoff)s
        Default=0.2.
    %(upper_cutoff)s
        Default=0.85.
    %(connected)s
        Default=True.
    %(opening)s
        Default=2.
    exclude_zeros : :obj:`bool`, optional
        Consider zeros as missing values for the computation of the
        threshold. This option is useful if the images have been
        resliced with a large padding of zeros.
        Default=False.
    %(target_affine)s

        .. note::
            This parameter is passed to :func:`nilearn.image.resample_img`.

    %(target_shape)s

        .. note::
            This parameter is passed to :func:`nilearn.image.resample_img`.

    %(memory)s
    %(n_jobs)s

    Returns
    -------
    mask : 3D :class:`nibabel.nifti1.Nifti1Image`
        The brain mask.
    """
    ...

@_utils.fill_doc
def compute_background_mask(data_imgs, border_size=..., connected=..., opening=..., target_affine=..., target_shape=..., memory=..., verbose=...): # -> Nifti1Image | FileBasedImage:
    """Compute a brain mask for the images by guessing \
    the value of the background from the border of the image.

    Parameters
    ----------
    data_imgs : Niimg-like object
        See :ref:`extracting_data`.
        Images used to compute the mask. 3D and 4D images are accepted.

        .. note::

            If a 3D image is given, we suggest to use the mean image.

    %(border_size)s
        Default=2.
    %(connected)s
        Default=False.
    %(opening)s
        Default=False.
    %(target_affine)s

        .. note::
            This parameter is passed to :func:`nilearn.image.resample_img`.

    %(target_shape)s

        .. note::
            This parameter is passed to :func:`nilearn.image.resample_img`.

    %(memory)s
    %(verbose0)s

    Returns
    -------
    mask : :class:`nibabel.nifti1.Nifti1Image`
        The brain mask (3D image).
    """
    ...

@_utils.fill_doc
def compute_multi_background_mask(data_imgs, border_size=..., upper_cutoff=..., connected=..., opening=..., threshold=..., target_affine=..., target_shape=..., exclude_zeros=..., n_jobs=..., memory=..., verbose=...): # -> Nifti1Image | FileBasedImage:
    """Compute a common mask for several sessions or subjects of data.

    Uses the mask-finding algorithms to extract masks for each session
    or subject, and then keep only the main connected component of the
    a given fraction of the intersection of all the masks.

    Parameters
    ----------
    data_imgs : :obj:`list` of Niimg-like objects
        See :ref:`extracting_data`.
        A list of arrays, each item being a subject or a session.
        3D and 4D images are accepted.

        .. note::
            If 3D images are given, we suggest to use the mean image
            of each session.

    threshold : :obj:`float`, optional
        The inter-session threshold: the fraction of the
        total number of session in for which a :term:`voxel` must be
        in the mask to be kept in the common mask.
        threshold=1 corresponds to keeping the intersection of all
        masks, whereas threshold=0 is the union of all masks.
    %(border_size)s
        Default=2.
    %(connected)s
        Default=True.
    %(target_affine)s

        .. note::
            This parameter is passed to :func:`nilearn.image.resample_img`.

    %(target_shape)s

        .. note::
            This parameter is passed to :func:`nilearn.image.resample_img`.

    %(memory)s
    %(n_jobs)s

    Returns
    -------
    mask : 3D :class:`nibabel.nifti1.Nifti1Image`
        The brain mask.
    """
    ...

@_utils.fill_doc
def compute_brain_mask(target_img, threshold=..., connected=..., opening=..., memory=..., verbose=..., mask_type=...): # -> Nifti1Image | FileBasedImage:
    """Compute the whole-brain, grey-matter or white-matter mask.

    This mask is calculated using MNI152 1mm-resolution template mask onto the
    target image.

    Parameters
    ----------
    target_img : Niimg-like object
        See :ref:`extracting_data`.
        Images used to compute the mask. 3D and 4D images are accepted.
        Only the shape and affine of ``target_img`` will be used here.

    threshold : :obj:`float`, optional
        The value under which the :term:`MNI` template is cut off.
        Default=0.5
    %(connected)s
        Default=True.
    %(opening)s
        Default=2.
    %(memory)s
    %(verbose0)s
    %(mask_type)s

        .. versionadded:: 0.8.1

    Returns
    -------
    mask : :class:`nibabel.nifti1.Nifti1Image`
        The whole-brain mask (3D image).
    """
    ...

@_utils.fill_doc
def compute_multi_brain_mask(target_imgs, threshold=..., connected=..., opening=..., memory=..., verbose=..., n_jobs=..., mask_type=..., **kwargs): # -> Nifti1Image | FileBasedImage:
    """Compute the whole-brain, grey-matter or white-matter mask \
    for a list of images.

    The mask is calculated through the resampling of the corresponding
    MNI152 template mask onto the target image.

    .. versionadded:: 0.8.1

    Parameters
    ----------
    target_imgs : :obj:`list` of Niimg-like object
        See :ref:`extracting_data`.
        Images used to compute the mask. 3D and 4D images are accepted.

        .. note::
            The images in this list must be of same shape and affine.
            The mask is calculated with the first element of the list
            for only the shape/affine of the image is used for this
            masking strategy.

    threshold : :obj:`float`, optional
        The value under which the :term:`MNI` template is cut off.
        Default=0.5.
    %(connected)s
        Default=True.
    %(opening)s
        Default=2.
    %(mask_type)s
    %(memory)s
    %(verbose0)s
    %(n_jobs)s

        .. note::
            Argument not used but kept to fit the API

    **kwargs : optional arguments
        Arguments such as 'target_affine' are used in the call of other
        masking strategies, which then would raise an error for this function
        which does not need such arguments.

    Returns
    -------
    mask : :class:`nibabel.nifti1.Nifti1Image`
        The brain mask (3D image).

    See Also
    --------
    nilearn.masking.compute_brain_mask
    """
    ...

@fill_doc
def apply_mask(imgs, mask_img, dtype=..., smoothing_fwhm=..., ensure_finite=...): # -> ndarray[Any, dtype[Unknown]]:
    """Extract signals from images using specified mask.

    Read the time series from the given Niimg-like object, using the mask.

    Parameters
    ----------
    imgs : :obj:`list` of 4D Niimg-like objects
        See :ref:`extracting_data`.
        Images to be masked. list of lists of 3D images are also accepted.

    mask_img : Niimg-like object
        See :ref:`extracting_data`.
        3D mask array: True where a :term:`voxel` should be used.

    dtype: numpy dtype or 'f'
        The dtype of the output, if 'f', any float output is acceptable
        and if the data is stored on the disk as floats the data type
        will not be changed.
    %(smoothing_fwhm)s

        .. note::

            Implies ensure_finite=True.

    ensure_finite : :obj:`bool`
        If ensure_finite is True, the non-finite values (NaNs and
        infs) found in the images will be replaced by zeros.
        Default=True.

    Returns
    -------
    session_series : :class:`numpy.ndarray`
        2D array of series with shape (image number, :term:`voxel` number)

    Notes
    -----
    When using smoothing, ``ensure_finite`` is set to True, as non-finite
    values would spread across the image.
    """
    ...

def unmask(X, mask_img, order=...): # -> list[Unknown] | Nifti1Image | FileBasedImage:
    """Take masked data and bring them back into 3D/4D.

    This function can be applied to a list of masked data.

    Parameters
    ----------
    X : :class:`numpy.ndarray` (or :obj:`list` of)
        Masked data. shape: (samples #, features #).
        If X is one-dimensional, it is assumed that samples# == 1.

    mask_img : Niimg-like object
        See :ref:`extracting_data`.
        Must be 3-dimensional.

    Returns
    -------
    data : :class:`nibabel.nifti1.Nifti1Image`
        Unmasked data. Depending on the shape of X, data can have
        different shapes:

        - X.ndim == 2:
          Shape: (mask.shape[0], mask.shape[1], mask.shape[2], X.shape[0])
        - X.ndim == 1:
          Shape: (mask.shape[0], mask.shape[1], mask.shape[2])
    """
    ...

