"""
This type stub file was generated by pyright.
"""

from nibabel.onetime import auto_attr

"""Implement classes to handle statistical tests on likelihood models.

Author: Bertrand Thirion, 2011--2015
"""
inv_t_cdf = ...
class LikelihoodModelResults:
    """Class to contain results from likelihood models.

    This is the class in which things like AIC, BIC, llf
    can be implemented as methods, not computed in, say,
    the fit method of OLSModel.

    """
    def __init__(self, theta, Y, model, cov=..., dispersion=..., nuisance=..., rank=...) -> None:
        """Set up results structure.

        Parameters
        ----------
        theta : ndarray
            Parameter estimates from estimated model.

        Y : ndarray
            Data.

        model : ``LikelihoodModel`` instance
            Model used to generate fit.

        cov : None or ndarray, optional
            Covariance of thetas.

        dispersion : scalar, optional
            Multiplicative factor in front of `cov`.
            Default=1.

        nuisance : None of ndarray, optional
            Parameter estimates needed to compute logL.

        rank : None or scalar, optional
            Rank of the model.  If rank is not None, it is used for df_model
            instead of the usual counting of parameters.

        Notes
        -----
        The covariance of thetas is given by:

            dispersion * cov

        For (some subset of models) `dispersion` will typically be the mean
        square error from the estimated model (sigma^2)

        """
        ...
    
    @auto_attr
    def logL(self):
        """Return the maximized log-likelihood."""
        ...
    
    def t(self, column=...):
        """
        Return the (Wald) t-statistic for a given parameter estimate.

        Use Tcontrast for more complicated (Wald) t-statistics.

        """
        ...
    
    def vcov(self, matrix=..., column=..., dispersion=..., other=...): # -> Any | None:
        """Return Variance/covariance matrix of linear contrast.

        Parameters
        ----------
        matrix : (dim, self.theta.shape[0]) array, optional
            Numerical contrast specification, where ``dim`` refers to the
            'dimension' of the contrast i.e. 1 for t contrasts, 1 or more
            for F contrasts.

        column : int, optional
            Alternative way of specifying contrasts (column index).

        dispersion : float or (n_voxels,) array, optional
            Value(s) for the dispersion parameters.

        other : (dim, self.theta.shape[0]) array, optional
            Alternative contrast specification (?).

        Returns
        -------
        cov : (dim, dim) or (n_voxels, dim, dim) array
            The estimated covariance matrix/matrices.

        Returns the variance/covariance matrix of a linear contrast of the
        estimates of theta, multiplied by `dispersion` which will often be an
        estimate of `dispersion`, like, sigma^2.

        The covariance of interest is either specified as a (set of) column(s)
        or a matrix.

        """
        ...
    
    def Tcontrast(self, matrix, store=..., dispersion=...): # -> TContrastResults:
        """Compute a Tcontrast for a row vector `matrix`.

        To get the t-statistic for a single column, use the 't' method.

        Parameters
        ----------
        matrix : 1D array-like
            Contrast matrix.

        store : sequence, optional
            Components of t to store in results output object.
            Defaults to all components ('t', 'effect', 'sd').

        dispersion : None or float, optional

        Returns
        -------
        res : ``TContrastResults`` object

        """
        ...
    
    def Fcontrast(self, matrix, dispersion=..., invcov=...): # -> FContrastResults:
        """Compute an Fcontrast for a contrast matrix `matrix`.

        Here, `matrix` M is assumed to be non-singular. More precisely

        .. math::

            M pX pX' M'

        is assumed invertible. Here, :math:`pX` is the generalized inverse of
        the design matrix of the model.
        There can be problems in non-OLS models where
        the rank of the covariance of the noise is not full.

        See the contrast module to see how to specify contrasts.
        In particular, the matrices from these contrasts will always be
        non-singular in the sense above.

        Parameters
        ----------
        matrix : 1D array-like
            Contrast matrix.

        dispersion : None or float, optional
            If None, use ``self.dispersion``.

        invcov : None or array, optional
            Known inverse of variance covariance matrix.
            If None, calculate this matrix.

        Returns
        -------
        f_res : ``FContrastResults`` instance
            with attributes F, df_den, df_num

        Notes
        -----
        For F contrasts, we now specify an effect and covariance.

        """
        ...
    
    def conf_int(self, alpha=..., cols=..., dispersion=...): # -> NDArray[Any]:
        """Return the confidence interval of the specified theta estimates.

        Parameters
        ----------
        alpha : float, optional
            The `alpha` level for the confidence interval.
            ie., `alpha` = .05 returns a 95% confidence interval.
            Default=0.05.

        cols : tuple, optional
            `cols` specifies which confidence intervals to return.

        dispersion : None or scalar, optional
            Scale factor for the variance / covariance
            (see class docstring and ``vcov`` method docstring).

        Returns
        -------
        cis : ndarray
            `cis` is shape ``(len(cols), 2)`` where each row contains [lower,
            upper] for the given entry in `cols`

        Examples
        --------
        >>> from numpy.random import standard_normal as stan
        >>> from nilearn.glm import OLSModel
        >>> x = np.hstack((stan((30,1)),stan((30,1)),stan((30,1))))
        >>> beta=np.array([3.25, 1.5, 7.0])
        >>> y = np.dot(x,beta) + stan((30))
        >>> model = OLSModel(x).fit(y)
        >>> confidence_intervals = model.conf_int(cols=(1,2))

        Notes
        -----
        Confidence intervals are two-tailed.

        tails : string, optional
            Possible values: 'two' | 'upper' | 'lower'

        """
        ...
    


class TContrastResults:
    """Results from a t contrast of coefficients in a parametric model.

    The class does nothing.
    It is a container for the results from T contrasts,
    and returns the T-statistics when np.asarray is called.

    """
    def __init__(self, t, sd, effect, df_den=...) -> None:
        ...
    
    def __array__(self): # -> NDArray[Unknown]:
        ...
    
    def __str__(self) -> str:
        ...
    


class FContrastResults:
    """Results from an F contrast of coefficients in a parametric model.

    The class does nothing.
    It is a container for the results from F contrasts,
    and returns the F-statistics when np.asarray is called.
    """
    def __init__(self, effect, covariance, F, df_num, df_den=...) -> None:
        ...
    
    def __array__(self): # -> NDArray[Unknown]:
        ...
    
    def __str__(self) -> str:
        ...
    


